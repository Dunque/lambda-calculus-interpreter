true;
let x = true in x;
if false then true else false;
0;
succ (succ (succ 0));
3;
succ (pred 0);
iszero (pred (succ (succ 0)));
if iszero 3 then 0 else 1;
iszero true;
if 1 then true else false;
if iszero 3 then 0 else false;
let id = L x:Nat.x in id 3;
let id_bool = L x:Bool. x in id_bool true;
let id_nat = L x:Nat. x in id_nat 5;
let x = 5 in let id_nat = L x:Nat. x in id_nat x;
let fix = lambda f.(lambda x. f (lambda y. x x y)) (lambda x. f (lambda y. x x y)) in let sumaux = lambda f. (lambda n. (lambda m. if (iszero n) then m else succ (f (pred n) m))) in let sum = fix sumaux in sum 21 34;
let fix = lambda f.(lambda x. f (lambda y. x x y)) (lambda x. f (lambda y. x x y)) in let sumaux = lambda f. (lambda n. (lambda m. if (iszero n) then m else succ (f (pred n) m))) in let sum = fix sumaux in let prodaux = lambda f. (lambda n. (lambda m. if (iszero (pred n)) then m else sum (f (pred n) m) m)) in let prod = fix prodaux in prod 12 5;
concat ({1,"adios"}.2) ({"hola",2}.1);


{edad=12,nombre="pepe",par={1,2}};

{edad=12,nombre="pepe",par={1,2}}.edad;
{edad=12,nombre="pepe",par={1,2}}.nombre;
{edad=12,nombre="pepe",par={1,2}}.par;

record dentro de un par
({{edad=12,nombre="pepe",par={1,2}},2}.1).edad;


const[Nat] 3 const[Nat] 5 const[Nat] 1 nil[Nat];

[];
[1,2,3,4,5];
[1,"hola",3];
[true,false,true];
{edad=12,nombre="pepe",lista=[1,2,3,4,5]}.lista;
[[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5]];
[{1,2},{1,2},{1,2}];
let p={1,2} in p.1;

head [1,2,3,4,5];
tail [1,2,3,4,5];
isEmpty [1,2,3,4,5];
isEmpty [];
head ({edad=12,nombre="pepe",lista=[1,2,3,4,5]}.lista);
tail ({edad=12,nombre="pepe",lista=[1,2,3,4,5]}.lista);

L x:{Nat,Nat}. x.1;;

({{"hola",2},2}.1).1;
({{1,2},2}.1).1;
(({{{1,2},2},2}.1).1).1;
({"hola",2}).1;

type context = string * ty * term option

type command = 
    Eval of term
    | Bind of string * term

val addbinding : context -> string -> ty -> term -> context;;
val getbinding : context -> string -> ty -> context;;

val execute : context -> command -> context;




let execute ctx = function
    Eval tm ->
        let tyTm = typeof ctx tm in
        let tm' = eval ctx tm in
        print_endline (" - : " ^ string_of_ty tyTM ^" = " ^ string_of_term tm');
        ctx

    | Bind (s, tm) ->
        let tyTm = typeof ctx tm in
        let tm' = eval ctx tm in
        print_endline (" - : " ^ string_of_ty tyTM ^" = " ^ string_of_term tm');
        addbinding ctx s tm tytm

TmVar s -> 
    getbinding ctx s



main

let c = s token readline
loop execute ctx c


type <Lambda.command> s

letrec length:Nat = (L l:List.(L n:Nat.(if (isEmpty l) then n else (length (tail l) (succ n)))))  
in (length l 0);

letrec map = L f:Tm.(L l:TyList.(L l2:TyList.(if isEmptyList l then l2 else map f (tail l) (add (f (head l)) l2) )))
in map f l [];