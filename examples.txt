true;
let x = true in x;
if false then true else false;
0;
succ (succ (succ 0));
3;
succ (pred 0);
iszero (pred (succ (succ 0)));
if iszero 3 then 0 else 1;
iszero true;
if 1 then true else false;
if iszero 3 then 0 else false;
let id = L x:Nat.x in id 3;
let id_bool = L x:Bool. x in id_bool true;
let id_nat = L x:Nat. x in id_nat 5;
let x = 5 in let id_nat = L x:Nat. x in id_nat x;
let fix = lambda f.(lambda x. f (lambda y. x x y)) (lambda x. f (lambda y. x x y)) in let sumaux = lambda f. (lambda n. (lambda m. if (iszero n) then m else succ (f (pred n) m))) in let sum = fix sumaux in sum 21 34;
let fix = lambda f.(lambda x. f (lambda y. x x y)) (lambda x. f (lambda y. x x y)) in let sumaux = lambda f. (lambda n. (lambda m. if (iszero n) then m else succ (f (pred n) m))) in let sum = fix sumaux in let prodaux = lambda f. (lambda n. (lambda m. if (iszero (pred n)) then m else sum (f (pred n) m) m)) in let prod = fix prodaux in prod 12 5;
concat ({1,"adios"}.2) ({"hola",2}.1);


{edad=12,nombre="pepe",par={1,2}};

{edad=12,nombre="pepe",par={1,2}}.edad;
{edad=12,nombre="pepe",par={1,2}}.nombre;
{edad=12,nombre="pepe",par={1,2}}.par;

record dentro de un par
({{edad=12,nombre="pepe",par={1,2}},2}.1).edad;

-------------------------- LISTAS -----------------------------
nil[Nat];
const[Nat] 3 const[Nat] 5 const[Nat] 1 nil[Nat];
const[Bool] false const[Bool] true const[Bool] true nil[Bool];
{edad=12,nombre="pepe",lista=const[Nat] 3 const[Nat] 5 const[Nat] 1 nil[Nat]}.lista;

error de tipo
    const[Nat] 3 const[Bool] true const[Nat] 1 nil[Nat];

const[List Nat] (const[Nat] 3 const[Nat] 5 const[Nat] 1 nil[Nat]) const[List Nat] (const[Nat] 3 const[Nat] 5 const[Nat] 1 nil[Nat]) nil[List Nat];

const[{Nat,Nat}] {1,2} const[{Nat,Nat}] {1,2} const[{Nat,Nat}] {1,2} nil[{Nat,Nat}];

let l=const[Nat] 3 const[Nat] 5 const[Nat] 1 nil[Nat]; in head[Nat] l;

head[Nat] (const[Nat] 3 const[Nat] 5 const[Nat] 1 nil[Nat]);
tail[Nat] (const[Nat] 3 const[Nat] 5 const[Nat] 1 nil[Nat]);
isNil[Nat] (const[Nat] 3 const[Nat] 5 const[Nat] 1 nil[Nat]);
isNil[Nat] nil[Nat];

head[Nat] ({edad=12,nombre="pepe",lista=const[Nat] 3 const[Nat] 5 const[Nat] 1 nil[Nat]}.lista);
-----------------------------------------------------------------------------
L x:{Nat,Nat}. x.1;;

({{"hola",2},2}.1).1;
({{1,2},2}.1).1;
(({{{1,2},2},2}.1).1).1;
({"hola",2}).1;

type context = string * ty * term option

type command = 
    Eval of term
    | Bind of string * term

val addbinding : context -> string -> ty -> term -> context;;
val getbinding : context -> string -> ty -> context;;

val execute : context -> command -> context;




let execute ctx = function
    Eval tm ->
        let tyTm = typeof ctx tm in
        let tm' = eval ctx tm in
        print_endline (" - : " ^ string_of_ty tyTM ^" = " ^ string_of_term tm');
        ctx

    | Bind (s, tm) ->
        let tyTm = typeof ctx tm in
        let tm' = eval ctx tm in
        print_endline (" - : " ^ string_of_ty tyTM ^" = " ^ string_of_term tm');
        addbinding ctx s tm tytm

TmVar s -> 
    getbinding ctx s



main

let c = s token readline
loop execute ctx c


type <Lambda.command> s

letrec length:Nat = (L l:List.(L n:Nat.(if (isEmpty l) then n else (length (tail l) (succ n)))))  
in (length l 0);

letrec map = L f:Tm.(L l:TyList.(L l2:TyList.(if isEmptyList l then l2 else map f (tail l) (add (f (head l)) l2) )))
in map f l [];