true;
let x = true in x;
if false then true else false;
0;
succ (succ (succ 0));
3;
succ (pred 0);
iszero (pred (succ (succ 0)));
if iszero 3 then 0 else 1;
iszero true;
if 1 then true else false;
if iszero 3 then 0 else false;
let id = L x:Nat.x in id 3;
let id_bool = L x:Bool. x in id_bool true;
let id_nat = L x:Nat. x in id_nat 5;
let x = 5 in let id_nat = L x:Nat. x in id_nat x;
let fix = lambda f.(lambda x. f (lambda y. x x y)) (lambda x. f (lambda y. x x y)) in let sumaux = lambda f. (lambda n. (lambda m. if (iszero n) then m else succ (f (pred n) m))) in let sum = fix sumaux in sum 21 34;
let fix = lambda f.(lambda x. f (lambda y. x x y)) (lambda x. f (lambda y. x x y)) in let sumaux = lambda f. (lambda n. (lambda m. if (iszero n) then m else succ (f (pred n) m))) in let sum = fix sumaux in let prodaux = lambda f. (lambda n. (lambda m. if (iszero (pred n)) then m else sum (f (pred n) m) m)) in let prod = fix prodaux in prod 12 5;
concat ({1,"adios"}.2) ({"hola",2}.1);


{edad=12,nombre="pepe",par={1,2}};

{edad=12,nombre="pepe",par={1,2}}.edad;
{edad=12,nombre="pepe",par={1,2}}.nombre;
{edad=12,nombre="pepe",par={1,2}}.par;

record dentro de un par
({{edad=12,nombre="pepe",par={1,2}},2}.1).edad;


[];
[1,2,3,4,5];
[1,"hola",3];
[true,false,true];
{edad=12,nombre="pepe",lista=[1,2,3,4,5]}.lista;

head [1,2,3,4,5];
tail [1,2,3,4,5];
isEmpty [1,2,3,4,5];
isEmpty [];
head ({edad=12,nombre="pepe",lista=[1,2,3,4,5]}.lista);



({{"hola",2},2}.1).1;
({{1,2},2}.1).1;
(({{{1,2},2},2}.1).1).1;
({"hola",2}).1;

type context = string * ty * term option

type command = 
    Eval of term
    | Bind of string * term

val addbinding : context -> string -> ty -> term -> context;;
val getbinding : context -> string -> ty -> context;;

val execute : context -> command -> context;




let execute ctx = function
    Eval tm ->
        let tyTm = typeof ctx tm in
        let tm' = eval ctx tm in
        print_endline (" - : " ^ string_of_ty tyTM ^" = " ^ string_of_term tm');
        ctx

    | Bind (s, tm) ->
        let tyTm = typeof ctx tm in
        let tm' = eval ctx tm in
        print_endline (" - : " ^ string_of_ty tyTM ^" = " ^ string_of_term tm');
        addbinding ctx s tm tytm

TmVar s -> 
    getbinding ctx s



main

let c = s token readline
loop execute ctx c


type <Lambda.command> s


s:
    stringv eq term Eof
        { bind ($1, $3) }
    | term Eof
        { Eval $1 }




        tuplas y registros en la zona de atomic term y los campos son term
        añadir a mayores 
        record:
        term o recordterm



        enla funcion eval: añadir en no term applies qeu navegue el termino, y que cuando 
        encuentre un tm var si no es una variable ligada que vaya al contexto y la sustituya por su valor.
        meter en la lista de variables ligadas ( las que llevan punto Lx. ->esa x la meto)